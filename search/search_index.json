{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Documentation Projet Java - Kamisado - M3105 - CHIGNARD Julien DEMAISON Christel Pr\u00e9sentation Le projet est un jeu de plateau, nomm\u00e9 \"Kamisado\". Le plateau est un cadrillage 8 par 8 donc les cases peuvent \u00eatre de 8 couleurs diff\u00e9rentes. Deux joueurs s'affrontent, chacun poss\u00e8de 8 pieces, chacune d'une des 8 couleur du plateau, qui peuvent etre deplac\u00e9es horizontalement, verticalement, et en diagonale. Le premier joueur avance la pi\u00e8ce de son choix et la couleur de la case sur laquel ladite pi\u00e8ce s'arretera d\u00e9terminera quel pion le joueur suivant devra jouer. Le but du jeu est d'amener un pion sur la derni\u00e8re ligne adverse. Si il y a plusieur manches, alors lorsqu'une pi\u00e8ce arrive sur la ligne adverse, elle devient un sumo1 et le joueur emporte un point.Le sumo1 ne peut se d\u00e9lacer que de 5 cases, mais peut pousser un pion adverse d'une case si il le rencontre. Le jeu se remet en place comme en debut de partie. Si un Sumo1 arrive sur la ligne adverse, il devient alors Sumo2. Le Sumo2 ne peut se d\u00e9lacer que de 3 cases, mais peut pousser deux pions adverses se situer cote a cote d'une case si il les rencontre. Le jeu poss\u00e8de un menu pour d\u00e9marer une partie, choisir le nombre de manche, et lire les r\u00e8gles.","title":"Introduction"},{"location":"#introduction","text":"Documentation Projet Java - Kamisado - M3105 - CHIGNARD Julien DEMAISON Christel","title":"Introduction"},{"location":"#presentation","text":"Le projet est un jeu de plateau, nomm\u00e9 \"Kamisado\". Le plateau est un cadrillage 8 par 8 donc les cases peuvent \u00eatre de 8 couleurs diff\u00e9rentes. Deux joueurs s'affrontent, chacun poss\u00e8de 8 pieces, chacune d'une des 8 couleur du plateau, qui peuvent etre deplac\u00e9es horizontalement, verticalement, et en diagonale. Le premier joueur avance la pi\u00e8ce de son choix et la couleur de la case sur laquel ladite pi\u00e8ce s'arretera d\u00e9terminera quel pion le joueur suivant devra jouer. Le but du jeu est d'amener un pion sur la derni\u00e8re ligne adverse. Si il y a plusieur manches, alors lorsqu'une pi\u00e8ce arrive sur la ligne adverse, elle devient un sumo1 et le joueur emporte un point.Le sumo1 ne peut se d\u00e9lacer que de 5 cases, mais peut pousser un pion adverse d'une case si il le rencontre. Le jeu se remet en place comme en debut de partie. Si un Sumo1 arrive sur la ligne adverse, il devient alors Sumo2. Le Sumo2 ne peut se d\u00e9lacer que de 3 cases, mais peut pousser deux pions adverses se situer cote a cote d'une case si il les rencontre. Le jeu poss\u00e8de un menu pour d\u00e9marer une partie, choisir le nombre de manche, et lire les r\u00e8gles.","title":"Pr\u00e9sentation"},{"location":"Analyse/","text":"Analyse Focntionnement du prgramme dans son ensemble Classes utilis\u00e9es: Pi\u00e8ce Board Fenetre Game Fonctionnement global: Le programme utilise 2 tableaux de pi\u00e8ces, qui corespondent aux pi\u00e8ce de chaque joueur. Ces pi\u00e8ces poss\u00e8dent une donn\u00e9e x et une y pour leur localisation sur le plateau, un num\u00e9ro pour identifier leur couleur et un statut pour d\u00e9terminer si elles sont sumo1, sumo2 ou simple pi\u00e8ce. A chaque tour le d\u00e9placement est v\u00e9rifi\u00e9 dans les fonction membbre de Piece, puis les collisions sont v\u00e9rifi\u00e9es en parcourant les position des differents pions grace auxtableaux. La position est ensuite valid\u00e9e, ou non, et le pion se d\u00e9placera, ou la case deviendra rouge. Classes : [Piece] La classe Piece sert \u00e0 g\u00e9rer les pions, leur cr\u00e9ation, leurs m\u00e9thodes et comme ils interagissent entre eux. Cette classe est primodiale pour le fonctionnement du programme car sans elle le jeu n'est rien ! [Board] La classe Board est la classe \"Principale\" du jeu, elle g\u00e8re les interactions utilisateur, les menus, les mouvements des pi\u00e8ces, etc... C'est la plus volumineuse, c'est dans cette classe qu'est le mouseListener servant \u00e0 suivre les mouvements de la souris et de pouvoir g\u00e9rer les clics pour pouvoir jouer. [Fenetre] Classe h\u00e9ritant de JFrame , elle sert \u00e0 cr\u00e9er la fen\u00eatre de d\u00e9part dans laquelle on appelera Board() pour afficher le plateau de jeu. [Game] le main du programme se trouve i\u00e7i, il construit et appelle une instance de Fenetre .","title":"Analyse"},{"location":"Analyse/#analyse","text":"Focntionnement du prgramme dans son ensemble","title":"Analyse"},{"location":"Analyse/#classes-utilisees","text":"Pi\u00e8ce Board Fenetre Game","title":"Classes utilis\u00e9es:"},{"location":"Analyse/#fonctionnement-global","text":"Le programme utilise 2 tableaux de pi\u00e8ces, qui corespondent aux pi\u00e8ce de chaque joueur. Ces pi\u00e8ces poss\u00e8dent une donn\u00e9e x et une y pour leur localisation sur le plateau, un num\u00e9ro pour identifier leur couleur et un statut pour d\u00e9terminer si elles sont sumo1, sumo2 ou simple pi\u00e8ce. A chaque tour le d\u00e9placement est v\u00e9rifi\u00e9 dans les fonction membbre de Piece, puis les collisions sont v\u00e9rifi\u00e9es en parcourant les position des differents pions grace auxtableaux. La position est ensuite valid\u00e9e, ou non, et le pion se d\u00e9placera, ou la case deviendra rouge.","title":"Fonctionnement global:"},{"location":"Analyse/#classes","text":"","title":"Classes :"},{"location":"Analyse/#piece","text":"La classe Piece sert \u00e0 g\u00e9rer les pions, leur cr\u00e9ation, leurs m\u00e9thodes et comme ils interagissent entre eux. Cette classe est primodiale pour le fonctionnement du programme car sans elle le jeu n'est rien !","title":"[Piece]"},{"location":"Analyse/#board","text":"La classe Board est la classe \"Principale\" du jeu, elle g\u00e8re les interactions utilisateur, les menus, les mouvements des pi\u00e8ces, etc... C'est la plus volumineuse, c'est dans cette classe qu'est le mouseListener servant \u00e0 suivre les mouvements de la souris et de pouvoir g\u00e9rer les clics pour pouvoir jouer.","title":"[Board]"},{"location":"Analyse/#fenetre","text":"Classe h\u00e9ritant de JFrame , elle sert \u00e0 cr\u00e9er la fen\u00eatre de d\u00e9part dans laquelle on appelera Board() pour afficher le plateau de jeu.","title":"[Fenetre]"},{"location":"Analyse/#game","text":"le main du programme se trouve i\u00e7i, il construit et appelle une instance de Fenetre .","title":"[Game]"},{"location":"Conclusion/","text":"Conclusion Bilan Optimisation possible Suppression des redondance en regroupant les calculs de collisions dans des fonctions Redimensionnement de la fen\u00eatre Fragmentation du code Extension Possible Rajout du Sumo3: peut se d\u00e9placer d'une case et pousser 3 pions. Animations de d\u00e9placement IA \"basique\" al\u00e9atoire 3D ?","title":"Conclusion"},{"location":"Conclusion/#conclusion","text":"","title":"Conclusion"},{"location":"Conclusion/#bilan","text":"","title":"Bilan"},{"location":"Conclusion/#optimisation-possible","text":"Suppression des redondance en regroupant les calculs de collisions dans des fonctions Redimensionnement de la fen\u00eatre Fragmentation du code","title":"Optimisation possible"},{"location":"Conclusion/#extension-possible","text":"Rajout du Sumo3: peut se d\u00e9placer d'une case et pousser 3 pions. Animations de d\u00e9placement IA \"basique\" al\u00e9atoire 3D ?","title":"Extension Possible"},{"location":"Realisation/","text":"R\u00e9alisation Les choix et m\u00e9thodes employ\u00e9es Choix techniques Utilisation de deux tableaux pour stocker les pieces Utilisation d'un vecteur pour lister les pieces sur la trajectoire du pion Gestion visuelle des trajectoires Code peu fragment\u00e9 Pr\u00e9sentation de certains algorithmes \"complexes\" utilis\u00e9s Algorithme de d\u00e9tection de pions dans une trajectoire diagonale if(Math.abs(xClicked-xPlay) == Math.abs(yClicked-yPlay)) { System.out.println(\"Verif diag\"); int pg = yClicked yPlay?yClicked:yPlay; int pp = pg==yClicked?yPlay:yClicked; int pp2 = pp==yClicked?xClicked:xPlay; boolean plus = (xPlay =xClicked yPlay =yClicked) || ((xPlay xClicked yPlay yClicked)); int ikse; for(int i=pp;i pg;i=i+100) { ikse=plus?pp2+(i-pp):pp2-(i-pp); for (int k=0; k 8; k++) { if ((i+30==j2[k].posY ikse+30==j2[k].posX) || (i+30==j1[k].posY ikse+30==j1[k].posX k!=numpion)) { System.out.println(\"Occupado diag \"+i); wrongPlace = true; occupied = true; break; } if(occupied) break; } } } On commence par regarder si les deux cases sont bien en diagonale l'une par rapport \u00e0 l'autre : if(Math.abs(xClicked-xPlay) == Math.abs(yClicked-yPlay)) Puis gr\u00e2ce aux op\u00e9rateurs ternaires on identifie l'ordre de croissance des coordonn\u00e9es x et y entre les deux cases : int pg = yClicked yPlay?yClicked:yPlay; # plus grand y int pp = pg==yClicked?yPlay:yClicked; # plus petit y int pp2 = pp==yClicked?xClicked:xPlay; # plus petit x On doit ensuite v\u00e9rifier la direction de la diagonale, car la proc\u00e9dure fonctionne en augmentant par pas de 100 (largeur d'une case) la coordonn\u00e9e y, pour avoir une diagonale il nous faut donc faire varier d'autant la coordonn\u00e9e x. Pour\u00e7a il nous faut savoir si quand y augmentant y le x cro\u00eet ou d\u00e9cro\u00eet. En fonction de cette derni\u00e8re information on saura comment faire varier x. boolean plus = (xPlay =xClicked yPlay =yClicked) || ((xPlay xClicked yPlay yClicked)); Pour faire court on veut savoir si la case cliqu\u00e9e est soit : En haut a droite de l'autre case ou en bas \u00e0 gauche. (= plus = false) En haut \u00e0 gauche de l'autre case ou en bas \u00e0 droite. (= plus = true) Maintenant qu'on sait de ou \u00e0 ou va notre diagonale, dans quelle direction, dans quel sens et comment laparcourir, il nous reste simplement \u00e0 la parcourir : for(int i=pp;i pg;i=i+100) { # Pour chaque y sur la diagonale ikse=plus?pp2+(i-pp):pp2-(i-pp); # On d\u00e9termine son x associ\u00e9 for (int k=0; k 8; k++) # Et on teste si d'autres pions se trouvent la { Il nous reste plus qu'a tester concr\u00e9tement si un autre pion est sur une de ces cases : if ((i+30==j2[k].posY ikse+30==j2[k].posX) || (i+30==j1[k].posY ikse+30==j1[k].posX k!=numpion)) On parcourt donc les deux tableau de pions, en omettant de se v\u00e9rifier soi-m\u00eame, pour des raisons \u00e9videntes. Le reste n'est pas tr\u00e8s int\u00e9rr\u00e9ssant, on consid\u00e8re le mouvement comme impossible, il devient caduque et on va envoyer cette informaton au gestionnaire de l'interface pour encadrer cette case en rouge. wrongPlace = true; occupied = true; break; } if(occupied) break;","title":"R\u00e9alisation"},{"location":"Realisation/#realisation","text":"Les choix et m\u00e9thodes employ\u00e9es","title":"R\u00e9alisation"},{"location":"Realisation/#choix-techniques","text":"Utilisation de deux tableaux pour stocker les pieces Utilisation d'un vecteur pour lister les pieces sur la trajectoire du pion Gestion visuelle des trajectoires Code peu fragment\u00e9","title":"Choix techniques"},{"location":"Realisation/#presentation-de-certains-algorithmes-complexes-utilises","text":"","title":"Pr\u00e9sentation de certains algorithmes \"complexes\" utilis\u00e9s"},{"location":"Realisation/#algorithme-de-detection-de-pions-dans-une-trajectoire-diagonale","text":"if(Math.abs(xClicked-xPlay) == Math.abs(yClicked-yPlay)) { System.out.println(\"Verif diag\"); int pg = yClicked yPlay?yClicked:yPlay; int pp = pg==yClicked?yPlay:yClicked; int pp2 = pp==yClicked?xClicked:xPlay; boolean plus = (xPlay =xClicked yPlay =yClicked) || ((xPlay xClicked yPlay yClicked)); int ikse; for(int i=pp;i pg;i=i+100) { ikse=plus?pp2+(i-pp):pp2-(i-pp); for (int k=0; k 8; k++) { if ((i+30==j2[k].posY ikse+30==j2[k].posX) || (i+30==j1[k].posY ikse+30==j1[k].posX k!=numpion)) { System.out.println(\"Occupado diag \"+i); wrongPlace = true; occupied = true; break; } if(occupied) break; } } } On commence par regarder si les deux cases sont bien en diagonale l'une par rapport \u00e0 l'autre : if(Math.abs(xClicked-xPlay) == Math.abs(yClicked-yPlay)) Puis gr\u00e2ce aux op\u00e9rateurs ternaires on identifie l'ordre de croissance des coordonn\u00e9es x et y entre les deux cases : int pg = yClicked yPlay?yClicked:yPlay; # plus grand y int pp = pg==yClicked?yPlay:yClicked; # plus petit y int pp2 = pp==yClicked?xClicked:xPlay; # plus petit x On doit ensuite v\u00e9rifier la direction de la diagonale, car la proc\u00e9dure fonctionne en augmentant par pas de 100 (largeur d'une case) la coordonn\u00e9e y, pour avoir une diagonale il nous faut donc faire varier d'autant la coordonn\u00e9e x. Pour\u00e7a il nous faut savoir si quand y augmentant y le x cro\u00eet ou d\u00e9cro\u00eet. En fonction de cette derni\u00e8re information on saura comment faire varier x. boolean plus = (xPlay =xClicked yPlay =yClicked) || ((xPlay xClicked yPlay yClicked)); Pour faire court on veut savoir si la case cliqu\u00e9e est soit : En haut a droite de l'autre case ou en bas \u00e0 gauche. (= plus = false) En haut \u00e0 gauche de l'autre case ou en bas \u00e0 droite. (= plus = true) Maintenant qu'on sait de ou \u00e0 ou va notre diagonale, dans quelle direction, dans quel sens et comment laparcourir, il nous reste simplement \u00e0 la parcourir : for(int i=pp;i pg;i=i+100) { # Pour chaque y sur la diagonale ikse=plus?pp2+(i-pp):pp2-(i-pp); # On d\u00e9termine son x associ\u00e9 for (int k=0; k 8; k++) # Et on teste si d'autres pions se trouvent la { Il nous reste plus qu'a tester concr\u00e9tement si un autre pion est sur une de ces cases : if ((i+30==j2[k].posY ikse+30==j2[k].posX) || (i+30==j1[k].posY ikse+30==j1[k].posX k!=numpion)) On parcourt donc les deux tableau de pions, en omettant de se v\u00e9rifier soi-m\u00eame, pour des raisons \u00e9videntes. Le reste n'est pas tr\u00e8s int\u00e9rr\u00e9ssant, on consid\u00e8re le mouvement comme impossible, il devient caduque et on va envoyer cette informaton au gestionnaire de l'interface pour encadrer cette case en rouge. wrongPlace = true; occupied = true; break; } if(occupied) break;","title":"Algorithme de d\u00e9tection de pions dans une trajectoire diagonale"},{"location":"Utilisation/","text":"Utilisation Comment utiliser ce programme Mode d'emploi Pour d\u00e9buter, vous serez invit\u00e9s \u00e0 choisir entre une partie rapide (1 manche), ou bien une partie personnalis\u00e9e avec un nombre choisi de manches et qui donc va prendre en compte l'utilisation de Sumos. Vous pouvez aussi Quitter le jeu. Le joueur noir commence la partie en s\u00e9l\u00e9ctionannt un pion \u00e0 bouger. Ensuite il peut le d\u00e9placer en cliquant sur une case du plateau et la partie commence. Pour d\u00e9placer un pion, il suffit de cliquer sur la case sur laquelle on veut d\u00e9placer le pion s\u00e9l\u00e9ctionn\u00e9, pour effectuer le d\u00e9placement. Si la case cliqu\u00e9e ne correspond pas a un mouvement possible du pion, alors elle sera signal\u00e9e en rouge.En d\u00e9but de partie ou de manche, le joueur noir doit cliquer sur le pion qu'il souaite d\u00e9placer. Le reste du temps, les pions sont automatiquement s\u00e9l\u00e9ctionn\u00e9s selon la case sur laquel s'est arreter le dernier pion. Le but du jeu est un peu comme aux dames de faire arriver un de ses pions \u00e0 la ligne arri\u00e8re du plateau. Une fois ce but atteint, si la partie \u00e9tait une partie rapide alors cette derni\u00e8re est termin\u00e9e, sinon le pion devient Sumo si il ne l'\u00e9tait pas et augmente de \"niveau\" de Sumo si il l'\u00e9tait d\u00e9ja (niveau 3 max.). De plus, le joueur aura remport\u00e9 la manche, si un joueur remporte autant de manches qu'il \u00e0 \u00e9t\u00e9 entr\u00e9 au d\u00e9but de la partie alors il gagne et la partie est tremin\u00e9e. Configuration requise Aucune configuration sp\u00e9ciale n'est requise.","title":"Utilisation"},{"location":"Utilisation/#utilisation","text":"Comment utiliser ce programme","title":"Utilisation"},{"location":"Utilisation/#mode-demploi","text":"Pour d\u00e9buter, vous serez invit\u00e9s \u00e0 choisir entre une partie rapide (1 manche), ou bien une partie personnalis\u00e9e avec un nombre choisi de manches et qui donc va prendre en compte l'utilisation de Sumos. Vous pouvez aussi Quitter le jeu. Le joueur noir commence la partie en s\u00e9l\u00e9ctionannt un pion \u00e0 bouger. Ensuite il peut le d\u00e9placer en cliquant sur une case du plateau et la partie commence. Pour d\u00e9placer un pion, il suffit de cliquer sur la case sur laquelle on veut d\u00e9placer le pion s\u00e9l\u00e9ctionn\u00e9, pour effectuer le d\u00e9placement. Si la case cliqu\u00e9e ne correspond pas a un mouvement possible du pion, alors elle sera signal\u00e9e en rouge.En d\u00e9but de partie ou de manche, le joueur noir doit cliquer sur le pion qu'il souaite d\u00e9placer. Le reste du temps, les pions sont automatiquement s\u00e9l\u00e9ctionn\u00e9s selon la case sur laquel s'est arreter le dernier pion. Le but du jeu est un peu comme aux dames de faire arriver un de ses pions \u00e0 la ligne arri\u00e8re du plateau. Une fois ce but atteint, si la partie \u00e9tait une partie rapide alors cette derni\u00e8re est termin\u00e9e, sinon le pion devient Sumo si il ne l'\u00e9tait pas et augmente de \"niveau\" de Sumo si il l'\u00e9tait d\u00e9ja (niveau 3 max.). De plus, le joueur aura remport\u00e9 la manche, si un joueur remporte autant de manches qu'il \u00e0 \u00e9t\u00e9 entr\u00e9 au d\u00e9but de la partie alors il gagne et la partie est tremin\u00e9e.","title":"Mode d'emploi"},{"location":"Utilisation/#configuration-requise","text":"Aucune configuration sp\u00e9ciale n'est requise.","title":"Configuration requise"}]}